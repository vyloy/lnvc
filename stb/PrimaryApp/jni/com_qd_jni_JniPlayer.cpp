/* DO NOT EDIT THIS FILE - it is machine generated */
#include <pthread.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/errno.h>
#include <stdlib.h>
#include "./com_qd_jni_JniPlayer.h"
//#include "mediastreamer2/msjava.h"
#include "../../tvdaemon/ipc/ipc_ctl.h"
#include "../../tvdaemon/ipc/pipe_ipc_packet.h"
#include "../../tvdaemon/ipc/fun_typedef.h"

/* Header for class com_qd_activity_JniUtil */

static JavaVM* gs_jvm=NULL;
static jobject gs_object=NULL;
static JavaVM *g_jvm = NULL;

static jclass g_jni_class = NULL;
static jmethodID g_jni_method[6] = {NULL};

static pthread_mutex_t	g_daemon_mutex;
static pthread_mutexattr_t	g_daemon_mutex_attr = PTHREAD_MUTEX_RECURSIVE_NP;

static int g_tvplay_pid = 0;
static int g_tvrecv_pid = 0;

static int g_freqency = 0;
static int g_modulation = 0;
static int g_symboRate = 0;
static int g_org_net_id = 0;
static int g_net_id = 0;
static int g_pmtPid = 0;
static int g_videoPid = 0;
static int g_audioPid = 0;
static int g_pcrPid = 0;
static int g_serviceId = 0;
static int g_tsId = 0;

static int g_pos_x = 0;
static int g_pos_y = 0;

static int g_size_width = 0;
static int g_size_height = 0;

enum	enum_play_statu
{
	e_stop,
	e_playing
	//e_stoping
};

enum_play_statu g_play_statu = e_playing;

char *p_log_tag_str = "tvcore";

extern "C" void child_tvrecv_packet_arrive(int pid, struct PipeIpcPacket &packet);
extern "C" void child_tvplay_packet_arrive(int pid, struct PipeIpcPacket &packet);
extern "C" void erase_pid_child_tvrecv(int pid);
extern "C" void erase_pid_child_tvplay(int pid);

void	stop_tvcore();
void	set_tvpos();
void	set_tvsize();
void	set_tvchannel();

int util_daemon_init();
static int surface_jni_init(JNIEnv* env);

extern "C"  JNIEXPORT jint JNICALL  JNI_OnLoad(JavaVM *ajvm, void *reserved)
{

	//ms_set_jvm(ajvm);
	g_jvm = ajvm;

	util_daemon_init();

	return JNI_VERSION_1_2;
}

extern	"C" void	internal_thread_loop_extern_run()
{
	pthread_mutex_lock(&g_daemon_mutex);
#if 0
	int child_pid = waitpid(-1, (int*)0, WNOHANG);
	if (child_pid > 0)
	{
		if(child_pid == g_tvrecv_pid)
		{
			LOGE("%s tvrecv exit pid:%d\n", __FUNCTION__, child_pid);
			//erase_child_pid(child_pid);
			//g_tvrecv_pid = 0;
		}
		else if(child_pid == g_tvplay_pid)
		{
			LOGE("%s tvplay exit pid:%d\n", __FUNCTION__, child_pid);
			//erase_child_pid(child_pid);
			//g_tvplay_pid = 0;
		}
	}
#endif

#if 0
	if((g_tvrecv_pid > 0 || g_tvplay_pid > 0) && (g_tvrecv_pid <= 0 || g_tvplay_pid <= 0))
	{
		if (e_playing == g_play_statu)
		{
			LOGE("%s line:%d g_tvrecv_pid:%d g_tvplay_pid:%d\n", __FUNCTION__, __LINE__, g_tvrecv_pid, g_tvplay_pid);
			pthread_mutex_unlock(&g_daemon_mutex);
			stop_tvcore();//放在后面，因为内部有锁，避免死锁。
			return;
		}

		pthread_mutex_unlock(&g_daemon_mutex);
		return;
	}

	if (e_stoping == g_play_statu
			&& g_tvplay_pid <= 0 && g_tvrecv_pid <= 0)
	{
		g_play_statu = e_stop;
	}
#endif

	if (e_stop != g_play_statu){
		pthread_mutex_unlock(&g_daemon_mutex);
		return;
	}

	/*
	if (mkfifo("/data/test/fifo1", S_IFIFO | 0666) == -1)
	{
		log_printf("mk fifo1 faile errno:%d\n", errno);
	}
	
	if (mkfifo("/data/test/fifo2", S_IFIFO | 0666) == -1)
	{
		log_printf("mk fifo2 faile errno:%d\n", errno);
	}
	*/
	
	//create_pipe_child((char*)"/data/test/tvplay", g_tvplay_pid
	//								, child_tvplay_packet_arrive, erase_pid_child_tvplay, 0);
	int	argc = 0;
	char argv_arg[12][128];
	char argv_value[12][32];
    memset(argv_arg, 0, sizeof(argv_arg));
	memset(argv_value, 0, sizeof(argv_value));

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "demuxer");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%s", "+mpegts");
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "vc");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%s", "android");
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "%s", "/data/lnt/fifo1");
	argc++;

    create_pipe_child((char*)"/data/lnt/tvplay2", g_tvplay_pid
									, child_tvplay_packet_arrive, erase_pid_child_tvplay
								    , 5
									, argv_arg[0], argv_value[0]
									, argv_arg[1], argv_value[1]
                                    , argv_arg[2]);
		

    argc = 0;

	memset(argv_arg, 0, sizeof(argv_arg));
	memset(argv_value, 0, sizeof(argv_value));

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "freqency");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_freqency);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "modulation");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_modulation);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "symboRate");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_symboRate);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "org_net_id");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_org_net_id);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "net_id");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_net_id);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "pmtPid");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_pmtPid);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "videoPid");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_videoPid);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "audioPid");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_audioPid);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "pcrPid");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_pcrPid);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "serviceId");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_serviceId);
	argc++;

	snprintf(argv_arg[argc], sizeof(argv_arg[0]) - 1, "-%s", "tsId");
	snprintf(argv_value[argc], sizeof(argv_value[0]) - 1, "%d", g_tsId);
	argc++;

//	static int g_freqency = 0;
//	static int g_modulation = 0;
//	static int g_symboRate = 0;
//	static int g_pmtPid = 0;
//	static int g_videoPid = 0;
//	static int g_audioPid = 0;
//	static int g_pcrPid = 0;
//	static int g_serviceId = 0;
//	static int g_tsId = 0;
	create_pipe_child((char*)"/data/lnt/tvrecv", g_tvrecv_pid
									, child_tvrecv_packet_arrive, erase_pid_child_tvrecv
									, argc * 2
									, argv_arg[0], argv_value[0]
									, argv_arg[1], argv_value[1]
									, argv_arg[2], argv_value[2]
									, argv_arg[3], argv_value[3]
									, argv_arg[4], argv_value[4]
									, argv_arg[5], argv_value[5]
									, argv_arg[6], argv_value[6]
									, argv_arg[7], argv_value[7]
									, argv_arg[8], argv_value[8]
									, argv_arg[9], argv_value[9]
									, argv_arg[10], argv_value[10]);

	if (g_tvplay_pid > 0 || g_tvrecv_pid > 0)
	{
		LOGE("%s line:%d g_tvrecv_pid:%d g_tvplay_pid:%d\n", __FUNCTION__, __LINE__, g_tvrecv_pid, g_tvplay_pid);
		g_play_statu = e_playing;
	}

	pthread_mutex_unlock(&g_daemon_mutex);
	
//	set_tvpos();
//	set_tvsize();
//	set_tvchannel();
}

extern "C" void	internal_thread_loop_extern_exit()
{
	pthread_mutex_lock(&g_daemon_mutex);
	pthread_mutex_unlock(&g_daemon_mutex);
}

void	stop_tvcore()
{
    LOGI("%s\n", __FUNCTION__);
	if (e_playing != g_play_statu)
	{
		return;
	}

	struct PipeIpcPacket exit_packet;
	exit_packet.m_command = CHILD_EXIT_COMMAND;
	
	if (0 != g_tvrecv_pid)
	{
        LOGI("%s exit tvrecv pid:%d\n", __FUNCTION__, g_tvrecv_pid);
		send_pid_packet(g_tvrecv_pid, exit_packet);

        int child_pid = waitpid(g_tvrecv_pid, (int*)0, 0);
        if(child_pid == g_tvrecv_pid) 
            LOGE("%s tvrecv exit pid:%d\n", __FUNCTION__, child_pid);
        erase_child_pid(g_tvrecv_pid);
        g_tvrecv_pid = 0;
	}
	if (0 != g_tvplay_pid)
	{
        LOGI("%s exit tvplay pid:%d\n", __FUNCTION__, g_tvplay_pid);
		send_pid_packet(g_tvplay_pid, exit_packet);
        int child_pid = waitpid(g_tvplay_pid, (int*)0, 0);
        if(child_pid == g_tvplay_pid) 
            LOGE("%s tvrecv exit pid:%d\n", __FUNCTION__, child_pid);
        erase_child_pid(g_tvplay_pid);
        g_tvplay_pid = 0;
	}
    LOGI("%s end\n", __FUNCTION__);
}
//
//void	set_tvpos()
//{
//	if (e_playing != g_play_statu)
//	{
//		return;
//	}
//
//	PipeIpcPacket pos_packet;
//	pos_packet.m_command = CHILD_SET_POS;
//	pos_packet.m_param[0] = g_pos_x;
//	pos_packet.m_param[1] = g_pos_y;
//
////	if (g_tvplay_pid > 0)
////	{
////		send_pid_packet(g_tvplay_pid, pos_packet);
////	}
//}
//
//void	set_tvsize()
//{
//	if (e_playing != g_play_statu)
//	{
//		return;
//	}
//
//	PipeIpcPacket size_packet;
//	size_packet.m_command = CHILD_SET_SIZE;
//	size_packet.m_param[0] = g_size_width;
//	size_packet.m_param[1] = g_size_height;
//
////	if (g_tvplay_pid > 0)
////	{
////		send_pid_packet(g_tvplay_pid, size_packet);
////	}
//}

//void	set_tvchannel()
//{
//	if (e_playing != g_play_statu)
//	{
//		return;
//	}
//
//	PipeIpcPacket play_channel_packet;
//	play_channel_packet.m_command = CHILD_PLAY_CHANNEL_COMMAND;
//
//	play_channel_packet.m_param[0] = g_freqency;
//	play_channel_packet.m_param[1] = g_modulation;
//	play_channel_packet.m_param[2] = g_symboRate;
//	play_channel_packet.m_param[3] = g_pmtPid;
//	play_channel_packet.m_param[4] = g_videoPid;
//	play_channel_packet.m_param[5] = g_audioPid;
//	play_channel_packet.m_param[6] = g_pcrPid;
//	play_channel_packet.m_param[7] = g_serviceId;
//	play_channel_packet.m_param[8] = g_tsId;
//
//
////	if (g_tvrecv_pid > 0)
////	{
////		send_pid_packet(g_tvrecv_pid, play_channel_packet);
////	}
//}

void child_tvrecv_packet_arrive(int pid, struct PipeIpcPacket &packet)
{
	if (CHILD_PLAY_CHANNEL_COMMAND == packet.m_command)
	{
//		log_printf("%s packet cmd:%d freqency:%d, modulation:%d, symboRate:%d, pmtPid:%d, videoPid:%d, \
//				audioPid:%d, pcrPid:%d, serviceId:%d, tsId:%d\n"
//				, __FUNCTION__
//				, packet.m_command
//				, packet.m_param[0]
//				, packet.m_param[1]
//				, packet.m_param[2]
//				, packet.m_param[3]
//				, packet.m_param[4]
//				, packet.m_param[5]
//				, packet.m_param[6]
//				, packet.m_param[7]
//				, packet.m_param[8]);
	}
}

void child_tvplay_packet_arrive(int pid, struct PipeIpcPacket &packet)
{
	if(CHILD_SET_POS == packet.m_command)
	{
//		log_printf("%s packet cmd:%d pos x:%d, y:%d\n"
//				, __FUNCTION__
//				, packet.m_command
//				, packet.m_param[0]
//				, packet.m_param[1]);
	}
	else if(CHILD_SET_SIZE == packet.m_command)
	{
//		log_printf("%s packet cmd:%d size width:%d, height:%d\n"
//				, __FUNCTION__
//				, packet.m_command
//				, packet.m_param[0]
//				, packet.m_param[1]);
	}
}

void erase_pid_child_tvrecv(int pid)
{
	log_printf("%s pid:%d\n", __FUNCTION__, pid);
	
//	JNIEnv *envforthread;
//	gs_jvm->AttachCurrentThread(&envforthread, NULL);
//	envforthread->CallVoidMethod(gs_object,g_jni_method[0], 0);
//	gs_jvm->DetachCurrentThread();
//
//	pthread_mutex_lock(&g_daemon_mutex);
//	g_tvrecv_erase_pid = pid;
//	g_tvrecv_pid = 0;
//	pthread_mutex_unlock(&g_daemon_mutex);
}

void erase_pid_child_tvplay(int pid)
{		
	log_printf("%s pid:%d\n", __FUNCTION__, pid);
	
//	JNIEnv *envforthread;
//	gs_jvm->AttachCurrentThread(&envforthread, NULL);
//	envforthread->CallVoidMethod(gs_object,g_jni_method[1], 1);
//	gs_jvm->DetachCurrentThread();
//
//	pthread_mutex_lock(&g_daemon_mutex);
//	g_tvplay_erase_pid = pid;
//	g_tvplay_pid = 0;
//	pthread_mutex_unlock(&g_daemon_mutex);
}

int util_javacallbackinit(JNIEnv* env,jobject thiz, jobject obj)
{
//	if (NULL != gs_object)
//	{
//		return 0;
//	}
//
//	g_jni_class=NULL;
//
//	for(int index = 0; index < sizeof(g_jni_method) / sizeof(g_jni_method[0]); ++index)
//	{
//		g_jni_method[index] = NULL;
//	}
//
//	g_jni_class=env->FindClass("com/qd/activity/JniUtil");
//	if(NULL == g_jni_class)
//	{
//		return -1;
//	}
//
//  g_jni_method[0]=env->GetMethodID(g_jni_class, "callbackInitUTI","(I)V");
//  g_jni_method[1]=env->GetMethodID(g_jni_class, "callbackPlayChannel","(I)V");
//  if(g_jni_method[0]==NULL || g_jni_method[1] == NULL)
//  {
//  	return -1;
//  }
//
//  env->GetJavaVM(&gs_jvm);
//  gs_object = env->NewGlobalRef(obj);
//
  return 0;
}


int util_daemon_init()
{
	//signal(SIGCHLD, SIG_IGN);
    //system("su");

	pthread_mutex_init(&g_daemon_mutex, &g_daemon_mutex_attr);

	create_ipc_install();
	return 0;
}

//JNIEXPORT jint JNICALL Java_com_qd_activity_JniUtil_initUTI
//  (JNIEnv *env, jobject thiz)
//{
//	if (0 != util_javacallbackinit(env, thiz, thiz))
//	{
//		return -2;
//	}
//
//	pthread_mutex_init(&g_daemon_mutex, &g_daemon_mutex_attr);
//
//	util_daemon_init();
//
//	return 0;
//}

#include <surfaceflinger/Surface.h>

#define ANDROID_VIEW_SURFACE_JNI_ID "mNativeSurface"
struct fields_t {
	//jfieldID    context;
	//jfieldID    surface;
	/* actually in android.view.Surface XXX */
	jfieldID    surface_native;
	//jmethodID   post_event;
};

static fields_t fields = {NULL};

static int surface_jni_init(JNIEnv* env) 
{
	if(fields.surface_native != NULL)
		return 0;

	jclass surface = env->FindClass("android/view/Surface");
	if (surface == NULL) {
		//jniThrowException(env, "java/lang/RuntimeException", "Can't find android/view/Surface");
		return -1;
	}

	fields.surface_native = env->GetFieldID(surface, ANDROID_VIEW_SURFACE_JNI_ID, "I");
	if (fields.surface_native == NULL) {
		//jniThrowException(env, "java/lang/RuntimeException", "Can't find Surface.mSurface");
		return -2;
	}

	return 0;
}

static Surface* get_surface(JNIEnv* env, jobject clazz)
{
	if(surface_jni_init(env) != 0)
		return -1;
    return (Surface*)env->GetIntField(clazz, fields.surface_native);
}

JNIEXPORT jint JNICALL Java_com_qd_jni_JniPlayer_setVideoSurface(JNIEnv *, jclass,
			jobject surface)
{
	if (surface != NULL) {
		const sp<Surface> native_surface = get_surface(env, surface);
		if(native_surface == NULL) {
			LOGE("get_surface == NULL\n");
			return -1;
		}
		LOGE("prepare: surface=%p (id=%d)",
				native_surface.get(), native_surface->getIdentity());
		
	}
	return 0;
}

JNIEXPORT jint JNICALL Java_com_qd_jni_JniPlayer_changeProgram
  (JNIEnv *, jclass, jint freqency, jint modulation, jint symboRate, jint org_net_id, jint net_id, jint pmtPid
		  , jint videoPid, jint audioPid, jint pcrPid, jint serviceId, jint tsId)
{
	//log_printf("%s\n", __FUNCTION__);
	LOGE("%s\n", __FUNCTION__);

	pthread_mutex_lock(&g_daemon_mutex);
	g_freqency = freqency;
	g_modulation = modulation;
	g_symboRate = symboRate;
	g_org_net_id = org_net_id;
	g_net_id = net_id;
	g_pmtPid = pmtPid;
	g_videoPid = videoPid;
	g_audioPid = audioPid;
	g_pcrPid = pcrPid;
	g_serviceId = serviceId;
	g_tsId = tsId;
	stop_tvcore();
    g_play_statu = e_stop;
    pthread_mutex_unlock(&g_daemon_mutex);

	return 0;
}

JNIEXPORT jint JNICALL Java_com_qd_jni_JniPlayer_setWindowSize
  (JNIEnv *, jclass, jint x, jint y, jint width, jint height)
{
	LOGE("%s\n", __FUNCTION__);

	pthread_mutex_lock(&g_daemon_mutex);
	g_pos_x = x;
	g_pos_y = y;
	g_size_width = width;
	g_size_height = height;
	pthread_mutex_unlock(&g_daemon_mutex);

	//set_tvpos();

	return 0;
}


JNIEXPORT jint JNICALL Java_com_qd_jni_JniPlayer_stopProgram
  (JNIEnv *, jclass)
{
	LOGE("%s\n", __FUNCTION__);
	//log_printf("%s\n", __FUNCTION__);

	pthread_mutex_lock(&g_daemon_mutex);
	stop_tvcore();
    g_play_statu = e_playing;
    pthread_mutex_unlock(&g_daemon_mutex);

	return 0;
}
