/*
 * HeadImagePanel.java
 *
 * Created on __DATE__, __TIME__
 */

package com.lorent.vovo.ui;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.MemoryImageSource;
import java.awt.image.PixelGrabber;
import java.io.File;
import java.net.URL;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

import com.lorent.vovo.util.Constants;
import com.lorent.vovo.util.ImageUtil;
import com.lorent.vovo.util.PicScale;

/**
 *
 * @author  __USER__
 */
public class HeadImagePanel extends javax.swing.JPanel {

	private Image headImg;
	private Image stateImg;
	private int state;
	private int w;
	private int h;
	private int originalWidth;
	private int OriginalHeight;
	private boolean isScale = false;

	/** Creates new form HeadImagePanel */
	public HeadImagePanel() {
		initComponents();
	}

	public HeadImagePanel(String imgUrl, int state, int w, int h) {
		try{
			ImageIcon icon;
			URL url;
			if (imgUrl != null && imgUrl.length() > 0) {
				url = getClass()
				.getResource(Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + imgUrl);
//				icon = new ImageIcon(getClass()
//						.getResource(Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + imgUrl));
			} else {
				url = getClass()
				.getResource(
						Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "head_1.jpg");
//				icon = new ImageIcon(
//						getClass()
//								.getResource(
//										Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "head_1.jpg"));
			}
			icon = new ImageIcon(url);
			init(icon.getImage(), state, w, h);
		}catch(Exception ex){
			ex.printStackTrace();
		}
	}

	private void setSteteImg(int state) {
		try{
			int scaleW = w;//(int)w/3;
			int scaleH = h;//(int)h/3;
			if (state == 0) {//离线
				stateImg = null;
			} else if (state == 1) {//在线
				stateImg = null;
			} else if (state == 2) {//离开
//				BufferedImage src = ImageIO.read(getClass().getResource(
//						Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "state_ico_away.png"));
//				src = PicScale.getInstance().resizeImage(src, scaleW, scaleH);
//				stateImg = new ImageIcon(src).getImage();
				stateImg = new ImageIcon(getClass().getResource(
						Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "state_ico_away.png")).getImage();
			} else if (state == 3) {//忙碌
//				BufferedImage src = ImageIO.read(getClass().getResource(
//						Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "state_ico_busy.png"));
//				src = PicScale.getInstance().resizeImage(src, scaleW, scaleH);
//				stateImg = new ImageIcon(src).getImage();
				stateImg = new ImageIcon(getClass().getResource(
						Constants.SYSTEM_HEAD_IMAGE_PATH_SYS + "state_ico_busy.png")).getImage();
			}
		}catch(Exception ex){
			
		}
	}

	private HeadImagePanel(Image headImg, int state) {
		this(headImg, state, headImg.getWidth(null), headImg.getHeight(null));
	}

	private HeadImagePanel(Image headImg, int state, int w, int h) {
		this();
		init(headImg, state, w, h);
	}

	public void init(Image headImg, int state, int w, int h) {
		this.headImg = headImg;
		this.state = state;
		this.w = w;
		this.h = h;
		setSteteImg(state);
		setMaximumSize(new java.awt.Dimension(w, h));
		setMinimumSize(new java.awt.Dimension(w, h));
		setPreferredSize(new java.awt.Dimension(w, h));
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	//GEN-BEGIN:initComponents
	// <editor-fold defaultstate="collapsed" desc="Generated Code">
	private void initComponents() {

		setOpaque(false);

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400,
				Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300,
				Short.MAX_VALUE));
	}// </editor-fold>
	//GEN-END:initComponents

	//GEN-BEGIN:variables
	// Variables declaration - do not modify
	// End of variables declaration//GEN-END:variables

	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		int width = w;
		int height = h;
		if (state == 0) {//离线
			Image r = GetPixels(headImg, 0, 0, headImg.getWidth(null), headImg
					.getHeight(null));
			r = PicScale.getInstance().resizeImage(ImageUtil.bufferImage(r, BufferedImage.TYPE_INT_RGB), width, height);
			g.drawImage(r, 0, 0, width, height, null);
		} else {//非离线状态
			// 将目标图片加载到内存。  
			if (stateImg != null) {
				BufferedImage bufferedImage = new BufferedImage(headImg
						.getWidth(null), headImg.getHeight(null),
						BufferedImage.TYPE_INT_RGB);//TYPE_INT_RGB
				Graphics2D gd = bufferedImage.createGraphics();
				gd.drawImage(headImg, 0, 0, headImg.getWidth(null), headImg
						.getHeight(null), null);

				// 加载水印图片。  
				//        Image waterImage = ImageIO.read(new File(waterImg));  
				int width_1 = stateImg.getWidth(null);
				int height_1 = stateImg.getHeight(null);
				// 设置水印图片的透明度。  
				//        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,  
				//                alpha));  

				// 设置水印图片的位置。  
				int widthDiff = headImg.getWidth(null) - width_1;
				int heightDiff = headImg.getHeight(null) - height_1;
				int x, y;
				x = widthDiff;
				y = heightDiff;

				// 将水印图片“画”在原有的图片的制定位置。  
				gd.drawImage(stateImg, x-3, y-3, width_1, height_1, null);
				// 关闭画笔。  
				gd.dispose();
				bufferedImage = PicScale.getInstance().resizeImage(ImageUtil.bufferImage(bufferedImage, BufferedImage.TYPE_INT_RGB), width, height);
				g.drawImage(bufferedImage, 0, 0, width, height, null);
			} else {
				headImg = PicScale.getInstance().resizeImage(ImageUtil.bufferImage(headImg, BufferedImage.TYPE_INT_RGB), width, height);
				g.drawImage(headImg, 0, 0, width, height, null);
			}
		}
	}

	public Image GetPixels(Image img, int x, int y, int w, int h) {
		int[] pixels = new int[w * h];
		//定义一块内存空间；  
		PixelGrabber pg = new PixelGrabber(img, x, y, w, h, pixels, 0, w);
		try {
			pg.grabPixels();
		} catch (InterruptedException e) {
			System.err.println("interrupted waiting for pixels!");
			return null;
		}
		for (int i = 0; i < h; i++) {
			for (int j = 0; j < w; j++) {
				// 获得像素的颜色  
				int color = pixels[w * i + j];
				int alpha = (color & 0xFF000000) >> 24;
				int red = (int) (((color & 0x00FF0000) >> 16) * 0.4);
				int green = (int) (((color & 0x0000FF00) >> 8) * 0.35);
				int blue = (int) ((color & 0x000000FF) * 0.11);
				color = red + green + blue;
				color = (alpha << 24) | (color << 16) | (color << 8) | color;
				//System.out.println(Integer.toHexString(color));  
				//由红，绿，蓝值得到灰度值；  
				pixels[w * i + j] = color;
			}
		}
		Image pic = createImage(new MemoryImageSource(w, h, pixels, 0, w));
		return pic;
	}

}