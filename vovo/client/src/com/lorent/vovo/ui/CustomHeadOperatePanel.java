/*
 * CustomHeadOperatePanel.java
 *
 * Created on __DATE__, __TIME__
 */

package com.lorent.vovo.ui;

import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

import com.lorent.vovo.util.PicScale;

/**
 *
 * @author  __USER__
 */
public class CustomHeadOperatePanel extends javax.swing.JPanel {

	private BufferedImage bufferedImage;
	private boolean flag = false;
	private CustomHeadRectangular customHeadRectangular;

	/** Creates new form CustomHeadOperatePanel */
	public CustomHeadOperatePanel() {
		initComponents();
	}

	public CustomHeadOperatePanel(String imgPath) {
		this();
		try {
			bufferedImage = ImageIO.read(new File(imgPath));
			setImageLabel();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public CustomHeadOperatePanel(BufferedImage bufferedImage) {
		this();
		this.bufferedImage = bufferedImage;
		setImageLabel();
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	//GEN-BEGIN:initComponents
	// <editor-fold defaultstate="collapsed" desc="Generated Code">
	private void initComponents() {

		setMinimumSize(new java.awt.Dimension(400, 300));
		setOpaque(false);
		setPreferredSize(new java.awt.Dimension(400, 300));
		addMouseListener(new java.awt.event.MouseAdapter() {
			public void mousePressed(java.awt.event.MouseEvent evt) {
				formMousePressed(evt);
			}

			public void mouseReleased(java.awt.event.MouseEvent evt) {
				formMouseReleased(evt);
			}
		});
		addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
			public void mouseDragged(java.awt.event.MouseEvent evt) {
				formMouseDragged(evt);
			}

			public void mouseMoved(java.awt.event.MouseEvent evt) {
				formMouseMoved(evt);
			}
		});
		setLayout(new java.awt.BorderLayout());
	}// </editor-fold>
	//GEN-END:initComponents

	private void formMousePressed(java.awt.event.MouseEvent evt) {
		customHeadRectangular.mousePressed(evt);
		this.repaint();
	}

	private void formMouseReleased(java.awt.event.MouseEvent evt) {
		customHeadRectangular.mouseReleased(evt);
	}

	private void formMouseDragged(java.awt.event.MouseEvent evt) {
		customHeadRectangular.mouseDragged(evt);
		this.repaint();
	}

	private void formMouseMoved(java.awt.event.MouseEvent evt) {
		customHeadRectangular.mouseMoved(evt);
	}

	private int scaleImgX;
	private int scaleImgY;
	private BufferedImage scaleBufferedImage;
	private int scaleImgWidth;
	private int scaleImgHeigth;

	public void setImageLabel() {
		double ratio = 0;
		double wRatio = 0;
		double hRatio = 0;

		//计算缩放比例
		if (bufferedImage.getWidth() > this.getPreferredSize().width) {
			wRatio = ((double) bufferedImage.getWidth())
					/ this.getPreferredSize().width;
			System.out.println("wRatio:" + wRatio);
		}
		if (bufferedImage.getHeight() > this.getPreferredSize().height) {
			hRatio = ((double) bufferedImage.getHeight())
					/ this.getPreferredSize().height;
			System.out.println("hRatio:" + hRatio);
		}
		System.out.println("bufferedImage.getWidth(): "
				+ bufferedImage.getWidth() + ";bufferedImage.getHeight(): "
				+ bufferedImage.getHeight());
		if (wRatio > 0 || hRatio > 0) {
			ratio = wRatio > hRatio ? wRatio : hRatio;
			System.out.println("ratio:" + ratio);
		}

		scaleImgWidth = bufferedImage.getWidth();
		scaleImgHeigth = bufferedImage.getHeight();
		//如果需要缩放，计算缩放后的图片尺寸
		if (ratio > 0) {
			scaleImgWidth = (int) (scaleImgWidth / ratio);
			scaleImgHeigth = (int) (scaleImgHeigth / ratio);
		}

		System.out.println("scaleImgWidth: " + scaleImgWidth
				+ ";scaleImgHeigth: " + scaleImgHeigth);
		System.out.println("this.getPreferredSize().width: "
				+ this.getPreferredSize().width
				+ ";this.getPreferredSize().height: "
				+ this.getPreferredSize().height);
		scaleImgX = (int) (this.getPreferredSize().width - scaleImgWidth) / 2;
		scaleImgY = (int) (this.getPreferredSize().height - scaleImgHeigth) / 2;
		System.out.println("scaleImgX: " + scaleImgX + ";scaleImgY: "
				+ scaleImgY);
		if (ratio > 0) {
			scaleBufferedImage = PicScale.getInstance().resizeImage(
					bufferedImage, scaleImgWidth, scaleImgHeigth);
		} else {
			scaleBufferedImage = bufferedImage;
		}
		javax.swing.JLabel imageLabel = new javax.swing.JLabel();
		imageLabel.setIcon(new ImageIcon(scaleBufferedImage));
		imageLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		imageLabel.setVerticalAlignment(javax.swing.SwingConstants.CENTER);
		this.add(imageLabel, java.awt.BorderLayout.CENTER);
	}

	//GEN-BEGIN:variables
	// Variables declaration - do not modify
	// End of variables declaration//GEN-END:variables

	public void paint(Graphics g) {
		super.paint(g);
		//		double ratio = 0;
		//		double wRatio = 0;
		//		double hRatio = 0;
		//
		//		//计算缩放比例
		//		if (bufferedImage.getWidth() > this.getPreferredSize().width) {
		//			wRatio = ((double) bufferedImage.getWidth())
		//					/ this.getPreferredSize().width;
		//			System.out.println("wRatio:" + wRatio);
		//		}
		//		if (bufferedImage.getHeight() > this.getPreferredSize().height) {
		//			hRatio = ((double) bufferedImage.getHeight())
		//					/ this.getPreferredSize().height;
		//			System.out.println("hRatio:" + hRatio);
		//		}
		//		System.out.println("bufferedImage.getWidth(): "
		//				+ bufferedImage.getWidth() + ";bufferedImage.getHeight(): "
		//				+ bufferedImage.getHeight());
		//		if (wRatio > 0 || hRatio > 0) {
		//			ratio = wRatio > hRatio ? wRatio : hRatio;
		//			System.out.println("ratio:" + ratio);
		//		}
		//
		//		int scaleImgWidth = bufferedImage.getWidth();
		//		int scaleImgHeigth = bufferedImage.getHeight();
		//		//如果需要缩放，计算缩放后的图片尺寸
		//		if (ratio > 0) {
		//			scaleImgWidth = (int) (scaleImgWidth / ratio);
		//			scaleImgHeigth = (int) (scaleImgHeigth / ratio);
		//		}
		//
		//		System.out.println("scaleImgWidth: " + scaleImgWidth
		//				+ ";scaleImgHeigth: " + scaleImgHeigth);
		//		System.out.println("this.getPreferredSize().width: "
		//				+ this.getPreferredSize().width
		//				+ ";this.getPreferredSize().height: "
		//				+ this.getPreferredSize().height);
		//		scaleImgX = (int) (this.getPreferredSize().width - scaleImgWidth) / 2;
		//		scaleImgY = (int) (this.getPreferredSize().height - scaleImgHeigth) / 2;
		//		System.out.println("scaleImgX: " + scaleImgX + ";scaleImgY: "
		//				+ scaleImgY);
		//		BufferedImage scaleBufferedImage = PicScale.getInstance().resizeImage(
		//				bufferedImage, scaleImgWidth, scaleImgHeigth);
		//		//画大图
		//		g.drawImage(scaleBufferedImage, scaleImgX, scaleImgY, scaleImgWidth,
		//				scaleImgHeigth, null);
		//画背景颜色
		Graphics2D g2 = (Graphics2D) g;
		Color color = g2.getColor();
		g2.setComposite(AlphaComposite.getInstance(3, 0.4F));
		g2.setColor(Color.BLACK);
		g2.fillRect(scaleImgX, scaleImgY, scaleImgWidth, scaleImgHeigth);
		g2.setColor(color);
		//	    g2.drawImage(scaleBufferedImage, scaleImgX, scaleImgY,scaleImgWidth,scaleImgHeigth, null);
		//	    if(!flag){
		//	    	
		//	    	g2.drawImage(scaleBufferedImage.getSubimage(scaleImgX, scaleImgY,scaleImgWidth/2,scaleImgHeigth/2), scaleImgX, scaleImgY, null);
		//	    	//画框
		//	    	g2.drawRect(scaleImgX, scaleImgY,scaleImgWidth/2,scaleImgHeigth/2);
		//	    }else{
		//	    	flag = true;
		//	    }
		//		System.out.println("paint scaleImgX: " + scaleImgX + ";scaleImgY: "
		//				+ scaleImgY);
		if (customHeadRectangular == null) {
			customHeadRectangular = new CustomHeadRectangular(this,
					scaleBufferedImage, scaleImgX, scaleImgY);
		}
		customHeadRectangular.draw(g);
		/*BufferedImageMax bufferedImageMax;
		//计算图片宽和高哪个值大
		if(bufferedImage.getWidth()>bufferedImage.getHeight()){
			bufferedImageMax = BufferedImageMax.Width;
		}else if(bufferedImage.getWidth()<bufferedImage.getHeight()){
			bufferedImageMax = BufferedImageMax.Height;
		}else{
			bufferedImageMax = BufferedImageMax.SameLength;
		}
		//计算是否需要缩放图片
		boolean isScaleImg = false;
		if(bufferedImageMax.equals(BufferedImageMax.Width)){
			isScaleImg = this.getPreferredSize().width>bufferedImage.getWidth() ? false:true;
		}else if(bufferedImageMax.equals(BufferedImageMax.Height)){
			isScaleImg = this.getPreferredSize().height>bufferedImage.getHeight() ? false:true;
		}else{
			int panelMax = this.getPreferredSize().width>this.getPreferredSize().height?this.getPreferredSize().width:this.getPreferredSize().height;
			isScaleImg = panelMax>bufferedImage.getHeight() ? false:true;
		}
		
		int scaleImgWidth = bufferedImage.getWidth();
		int scaleImgHeigth = bufferedImage.getHeight();
		//如果需要缩放，计算缩放后的图片尺寸
		if(isScaleImg){
			if(bufferedImageMax.equals(BufferedImageMax.Width)){
				scaleImgWidth = this.getPreferredSize().width;
				scaleImgHeigth = (int)(scaleImgWidth * this.getPreferredSize().height / bufferedImage.getWidth());
			}else if(bufferedImageMax.equals(BufferedImageMax.Height)){
				scaleImgHeigth = this.getPreferredSize().height;
				scaleImgWidth = (int)(scaleImgHeigth * this.getPreferredSize().width / bufferedImage.getHeight());
			}else{
				int panelMax = this.getPreferredSize().width>this.getPreferredSize().height?this.getPreferredSize().width:this.getPreferredSize().height;
				isScaleImg = panelMax>bufferedImage.getHeight() ? false:true;
			}
		}*/
	}

	private enum BufferedImageMax {
		Width, Height, SameLength
	}

	private Image doubleBuffer;

	public void update(Graphics g) {
		Dimension size = getSize();
		if (doubleBuffer.getWidth(this) != size.width
				|| doubleBuffer.getHeight(this) != size.height) {
			doubleBuffer = createImage(size.width, size.height);
		}
		if (doubleBuffer != null) {
			// 绘制到双缓存区
			Graphics g2 = doubleBuffer.getGraphics();
			paint(g2);
			g2.dispose();
			// 将双缓存复制到屏幕
			g.drawImage(doubleBuffer, 0, 0, null);
		} else {// 不要双缓存，只绘制屏幕
			paint(g);
		}
	}
}